<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Snake Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            position: relative;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #score {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 100;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        #highScore {
            position: absolute;
            top: 70px;
            left: 20px;
            color: #ffd700;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 100;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-align: center;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 100;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px 30px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            line-height: 1.5;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            z-index: 200;
            background: rgba(0, 0, 0, 0.8);
            padding: 40px;
            border-radius: 20px;
            backdrop-filter: blur(20px);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        #gameOver h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ff6b6b;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        #gameOver p {
            font-size: 24px;
            margin: 10px 0;
        }

        #finalScore {
            color: #ffd700;
            font-weight: bold;
            font-size: 32px;
        }

        #restartBtn {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #restartBtn:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.5);
        }

        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
        }

        #loadingText {
            font-size: 32px;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        #loadingBar {
            width: 300px;
            height: 30px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }

        #loadingProgress {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ffed4e);
            border-radius: 15px;
            width: 0%;
            transition: width 0.3s;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        #loadingPercent {
            margin-top: 10px;
            font-size: 18px;
        }

        #skinSelector {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        #skinSelector select {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
        }

        #skinSelector option {
            background: #333;
        }

        #speedIndicator {
            position: absolute;
            top: 120px;
            left: 20px;
            color: white;
            font-size: 16px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .powerup-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 150;
            pointer-events: none;
            animation: powerupPulse 2s ease-out;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        @keyframes powerupPulse {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div id="loadingText">Loading Game Assets</div>
        <div id="loadingBar">
            <div id="loadingProgress"></div>
        </div>
        <div id="loadingPercent">0%</div>
    </div>
    
    <div id="score">Score: 0</div>
    <div id="highScore">High Score: 0</div>
    <div id="speedIndicator">Speed: Normal</div>
    
    <div id="skinSelector">
        <select id="skinSelect">
            <option value="green">Green Snake</option>
            <option value="blue">Blue Snake</option>
            <option value="red">Red Snake</option>
            <option value="gold">Golden Snake</option>
        </select>
    </div>
    
    <div id="instructions">
        Use Arrow Keys or WASD to move | Eat food to grow | Avoid walls and yourself!<br>
        Power-ups: ðŸŸ¡ Speed Boost | ðŸ”µ Slow Motion | ðŸŸ£ Invincibility
    </div>
    
    <div id="gameOver" style="display: none;">
        <h1>Game Over!</h1>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button id="restartBtn">Play Again</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // IMPORTANT: Replace with your GitHub username and repository name
        const GITHUB_USERNAME = 'kody-w';
        const GITHUB_REPO = 'snake-game-assets';
        const ASSET_BASE_URL = `https://raw.githubusercontent.com/${GITHUB_USERNAME}/${GITHUB_REPO}/main`;

        // Game configuration
        const GRID_SIZE = 20;
        const INITIAL_SPEED = 100;
        const SPEED_INCREMENT = 5;
        const CELL_SIZE = 1;
        const WALL_HEIGHT = 2;

        // Game state
        let scene, camera, renderer;
        let snake = [];
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let food;
        let score = 0;
        let highScore = localStorage.getItem('snakeHighScore') || 0;
        let gameSpeed = INITIAL_SPEED;
        let lastMoveTime = 0;
        let gameRunning = true;
        let snakeMaterial;
        let foodMaterial;
        let wallMaterial;
        let groundMaterial;
        let particleSystem;
        let powerups = [];
        let activePowerup = null;
        let powerupEndTime = 0;
        let invincible = false;
        let speedMultiplier = 1;
        let textures = {};
        let loadedAssets = 0;
        let totalAssets = 0;
        let skybox;

        // Asset Manager Class
        class AssetManager {
            constructor(baseUrl) {
                this.baseUrl = baseUrl;
                this.textureLoader = new THREE.TextureLoader();
                this.textureLoader.crossOrigin = 'anonymous';
                this.textures = {};
                this.materials = {};
            }

            loadTexture(name, path, onProgress) {
                return new Promise((resolve, reject) => {
                    this.textureLoader.load(
                        `${this.baseUrl}/${path}`,
                        (texture) => {
                            this.textures[name] = texture;
                            if (onProgress) onProgress();
                            resolve(texture);
                        },
                        undefined,
                        (error) => {
                            console.warn(`Failed to load ${name}, using fallback`);
                            if (onProgress) onProgress();
                            resolve(null);
                        }
                    );
                });
            }

            async loadAllAssets(onProgress) {
                const assetList = [
                    { name: 'snake', path: 'textures/snake-scales.jpg' },
                    { name: 'snake-blue', path: 'textures/snake-scales-blue.jpg' },
                    { name: 'snake-red', path: 'textures/snake-scales-red.jpg' },
                    { name: 'snake-gold', path: 'textures/snake-scales-gold.jpg' },
                    { name: 'food', path: 'textures/apple.png' },
                    { name: 'food-green', path: 'textures/food-green.png' },
                    { name: 'food-gold', path: 'textures/food-gold.png' },
                    { name: 'ground', path: 'textures/grid.png' },
                    { name: 'wall', path: 'textures/brick.jpg' },
                    { name: 'powerup-speed', path: 'textures/powerup-speed.png' },
                    { name: 'powerup-slow', path: 'textures/powerup-slow.png' },
                    { name: 'powerup-invincible', path: 'textures/powerup-invincible.png' },
                    { name: 'particle', path: 'textures/particle.png' },
                    { name: 'skybox-px', path: 'textures/skybox/px.jpg' },
                    { name: 'skybox-nx', path: 'textures/skybox/nx.jpg' },
                    { name: 'skybox-py', path: 'textures/skybox/py.jpg' },
                    { name: 'skybox-ny', path: 'textures/skybox/ny.jpg' },
                    { name: 'skybox-pz', path: 'textures/skybox/pz.jpg' },
                    { name: 'skybox-nz', path: 'textures/skybox/nz.jpg' }
                ];

                totalAssets = assetList.length;
                const promises = assetList.map(asset => 
                    this.loadTexture(asset.name, asset.path, onProgress)
                );

                await Promise.all(promises);
                this.createMaterials();
                return this.textures;
            }

            createMaterials() {
                // Snake materials
                this.materials['snake-green'] = this.textures.snake ? 
                    new THREE.MeshPhongMaterial({ 
                        map: this.textures.snake,
                        shininess: 100,
                        specular: 0x222222
                    }) : 
                    new THREE.MeshPhongMaterial({ 
                        color: 0x00ff00,
                        shininess: 100
                    });

                this.materials['snake-blue'] = this.textures['snake-blue'] ? 
                    new THREE.MeshPhongMaterial({ 
                        map: this.textures['snake-blue'],
                        shininess: 100,
                        specular: 0x222222
                    }) : 
                    new THREE.MeshPhongMaterial({ 
                        color: 0x0088ff,
                        shininess: 100
                    });

                this.materials['snake-red'] = this.textures['snake-red'] ? 
                    new THREE.MeshPhongMaterial({ 
                        map: this.textures['snake-red'],
                        shininess: 100,
                        specular: 0x222222
                    }) : 
                    new THREE.MeshPhongMaterial({ 
                        color: 0xff0000,
                        shininess: 100
                    });

                this.materials['snake-gold'] = this.textures['snake-gold'] ? 
                    new THREE.MeshPhongMaterial({ 
                        map: this.textures['snake-gold'],
                        shininess: 150,
                        specular: 0x444444
                    }) : 
                    new THREE.MeshPhongMaterial({ 
                        color: 0xffd700,
                        shininess: 150
                    });

                // Food material
                this.materials.food = this.textures.food ? 
                    new THREE.MeshPhongMaterial({ 
                        map: this.textures.food,
                        emissive: 0x441111,
                        shininess: 80
                    }) : 
                    new THREE.MeshPhongMaterial({ 
                        color: 0xff0000,
                        emissive: 0x441111,
                        shininess: 80
                    });

                // Ground material
                if (this.textures.ground) {
                    this.textures.ground.wrapS = THREE.RepeatWrapping;
                    this.textures.ground.wrapT = THREE.RepeatWrapping;
                    this.textures.ground.repeat.set(GRID_SIZE / 2, GRID_SIZE / 2);
                }
                this.materials.ground = this.textures.ground ? 
                    new THREE.MeshLambertMaterial({ 
                        map: this.textures.ground,
                        side: THREE.DoubleSide
                    }) : 
                    new THREE.MeshLambertMaterial({ 
                        color: 0x333333,
                        side: THREE.DoubleSide
                    });

                // Wall material
                if (this.textures.wall) {
                    this.textures.wall.wrapS = THREE.RepeatWrapping;
                    this.textures.wall.wrapT = THREE.RepeatWrapping;
                }
                this.materials.wall = this.textures.wall ? 
                    new THREE.MeshPhongMaterial({ 
                        map: this.textures.wall
                    }) : 
                    new THREE.MeshPhongMaterial({ 
                        color: 0x8b4513
                    });

                // Power-up materials
                this.materials['powerup-speed'] = this.textures['powerup-speed'] ? 
                    new THREE.MeshPhongMaterial({ 
                        map: this.textures['powerup-speed'],
                        emissive: 0x444400,
                        transparent: true,
                        opacity: 0.9
                    }) : 
                    new THREE.MeshPhongMaterial({ 
                        color: 0xffff00,
                        emissive: 0x444400
                    });

                this.materials['powerup-slow'] = this.textures['powerup-slow'] ? 
                    new THREE.MeshPhongMaterial({ 
                        map: this.textures['powerup-slow'],
                        emissive: 0x004444,
                        transparent: true,
                        opacity: 0.9
                    }) : 
                    new THREE.MeshPhongMaterial({ 
                        color: 0x00ffff,
                        emissive: 0x004444
                    });

                this.materials['powerup-invincible'] = this.textures['powerup-invincible'] ? 
                    new THREE.MeshPhongMaterial({ 
                        map: this.textures['powerup-invincible'],
                        emissive: 0x440044,
                        transparent: true,
                        opacity: 0.9
                    }) : 
                    new THREE.MeshPhongMaterial({ 
                        color: 0xff00ff,
                        emissive: 0x440044
                    });
            }
        }

        // Initialize Three.js scene
        function initScene() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x1a1a2e, 10, 50);

            // Camera setup
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 25, 25);
            camera.lookAt(0, 0, 0);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -30;
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.top = 30;
            directionalLight.shadow.camera.bottom = -30;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0xffd700, 0.5, 20);
            pointLight.position.set(0, 10, 0);
            scene.add(pointLight);

            // Create skybox
            if (assetManager.textures['skybox-px']) {
                const skyboxGeometry = new THREE.BoxGeometry(100, 100, 100);
                const skyboxMaterials = [
                    new THREE.MeshBasicMaterial({ map: assetManager.textures['skybox-px'], side: THREE.BackSide }),
                    new THREE.MeshBasicMaterial({ map: assetManager.textures['skybox-nx'], side: THREE.BackSide }),
                    new THREE.MeshBasicMaterial({ map: assetManager.textures['skybox-py'], side: THREE.BackSide }),
                    new THREE.MeshBasicMaterial({ map: assetManager.textures['skybox-ny'], side: THREE.BackSide }),
                    new THREE.MeshBasicMaterial({ map: assetManager.textures['skybox-pz'], side: THREE.BackSide }),
                    new THREE.MeshBasicMaterial({ map: assetManager.textures['skybox-nz'], side: THREE.BackSide })
                ];
                skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterials);
                scene.add(skybox);
            }

            // Ground
            const groundGeometry = new THREE.PlaneGeometry(GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE);
            groundMaterial = assetManager.materials.ground;
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -CELL_SIZE / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Walls
            wallMaterial = assetManager.materials.wall;
            createWalls();

            // Initialize particle system
            createParticleSystem();
        }

        // Create walls
        function createWalls() {
            const wallGeometry = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE);
            
            for (let i = -GRID_SIZE/2; i <= GRID_SIZE/2; i++) {
                // Top wall
                const topWall = new THREE.Mesh(wallGeometry, wallMaterial);
                topWall.position.set(i * CELL_SIZE, WALL_HEIGHT/2, -GRID_SIZE/2 * CELL_SIZE);
                topWall.castShadow = true;
                scene.add(topWall);
                
                // Bottom wall
                const bottomWall = new THREE.Mesh(wallGeometry, wallMaterial);
                bottomWall.position.set(i * CELL_SIZE, WALL_HEIGHT/2, GRID_SIZE/2 * CELL_SIZE);
                bottomWall.castShadow = true;
                scene.add(bottomWall);
                
                // Left wall
                if (i !== -GRID_SIZE/2 && i !== GRID_SIZE/2) {
                    const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
                    leftWall.position.set(-GRID_SIZE/2 * CELL_SIZE, WALL_HEIGHT/2, i * CELL_SIZE);
                    leftWall.castShadow = true;
                    scene.add(leftWall);
                    
                    // Right wall
                    const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
                    rightWall.position.set(GRID_SIZE/2 * CELL_SIZE, WALL_HEIGHT/2, i * CELL_SIZE);
                    rightWall.castShadow = true;
                    scene.add(rightWall);
                }
            }
        }

        // Create particle system
        function createParticleSystem() {
            const particleGeometry = new THREE.BufferGeometry();
            const particleCount = 100;
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 50;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.1,
                transparent: true,
                opacity: 0.6,
                map: assetManager.textures.particle
            });
            
            particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleSystem);
        }

        // Initialize snake
        function initSnake() {
            // Clear existing snake
            snake.forEach(segment => scene.remove(segment.mesh));
            snake = [];
            
            // Get selected skin
            const skinSelect = document.getElementById('skinSelect');
            const selectedSkin = skinSelect.value;
            snakeMaterial = assetManager.materials[`snake-${selectedSkin}`];
            
            // Create initial snake
            const geometry = new THREE.BoxGeometry(CELL_SIZE * 0.9, CELL_SIZE * 0.9, CELL_SIZE * 0.9);
            
            for (let i = 0; i < 3; i++) {
                const segment = new THREE.Mesh(geometry, snakeMaterial);
                segment.position.set(-i * CELL_SIZE, 0, 0);
                segment.castShadow = true;
                segment.receiveShadow = true;
                scene.add(segment);
                snake.push({
                    position: { x: -i, y: 0 },
                    mesh: segment
                });
            }
        }

        // Create food
        function createFood() {
            if (food) {
                scene.remove(food.mesh);
            }
            
            const geometry = new THREE.SphereGeometry(CELL_SIZE * 0.4, 16, 16);
            foodMaterial = assetManager.materials.food;
            const mesh = new THREE.Mesh(geometry, foodMaterial);
            
            let position;
            do {
                position = {
                    x: Math.floor(Math.random() * (GRID_SIZE - 2)) - (GRID_SIZE / 2 - 1),
                    y: Math.floor(Math.random() * (GRID_SIZE - 2)) - (GRID_SIZE / 2 - 1)
                };
            } while (isPositionOccupied(position));
            
            mesh.position.set(position.x * CELL_SIZE, 0, position.y * CELL_SIZE);
            mesh.castShadow = true;
            scene.add(mesh);
            
            food = { position, mesh };
        }

        // Create power-up
        function createPowerup() {
            if (Math.random() > 0.3) return; // 30% chance to spawn power-up
            
            const types = ['speed', 'slow', 'invincible'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            const geometry = new THREE.OctahedronGeometry(CELL_SIZE * 0.5);
            const material = assetManager.materials[`powerup-${type}`];
            const mesh = new THREE.Mesh(geometry, material);
            
            let position;
            do {
                position = {
                    x: Math.floor(Math.random() * (GRID_SIZE - 2)) - (GRID_SIZE / 2 - 1),
                    y: Math.floor(Math.random() * (GRID_SIZE - 2)) - (GRID_SIZE / 2 - 1)
                };
            } while (isPositionOccupied(position));
            
            mesh.position.set(position.x * CELL_SIZE, CELL_SIZE, position.y * CELL_SIZE);
            mesh.castShadow = true;
            scene.add(mesh);
            
            powerups.push({ position, mesh, type });
        }

        // Check if position is occupied
        function isPositionOccupied(position) {
            // Check snake
            for (let segment of snake) {
                if (segment.position.x === position.x && segment.position.y === position.y) {
                    return true;
                }
            }
            
            // Check food
            if (food && food.position.x === position.x && food.position.y === position.y) {
                return true;
            }
            
            // Check power-ups
            for (let powerup of powerups) {
                if (powerup.position.x === position.x && powerup.position.y === position.y) {
                    return true;
                }
            }
            
            return false;
        }

        // Move snake
        function moveSnake() {
            if (!gameRunning) return;
            
            direction = { ...nextDirection };
            
            const head = snake[0];
            const newPosition = {
                x: head.position.x + direction.x,
                y: head.position.y + direction.y
            };
            
            // Check collisions
            if (!invincible && checkCollision(newPosition)) {
                gameOver();
                return;
            }
            
            // Move snake
            const newSegment = {
                position: newPosition,
                mesh: snake[snake.length - 1].mesh
            };
            
            // Update mesh position
            newSegment.mesh.position.set(
                newPosition.x * CELL_SIZE,
                0,
                newPosition.y * CELL_SIZE
            );
            
            // Add to front, remove from back
            snake.unshift(newSegment);
            snake.pop();
            
            // Check food collision
            if (food && newPosition.x === food.position.x && newPosition.y === food.position.y) {
                eatFood();
            }
            
            // Check power-up collision
            checkPowerupCollision(newPosition);
        }

        // Check collision
        function checkCollision(position) {
            // Wall collision
            if (Math.abs(position.x) >= GRID_SIZE / 2 || Math.abs(position.y) >= GRID_SIZE / 2) {
                return true;
            }
            
            // Self collision
            for (let i = 1; i < snake.length; i++) {
                if (snake[i].position.x === position.x && snake[i].position.y === position.y) {
                    return true;
                }
            }
            
            return false;
        }

        // Check power-up collision
        function checkPowerupCollision(position) {
            for (let i = 0; i < powerups.length; i++) {
                const powerup = powerups[i];
                if (powerup.position.x === position.x && powerup.position.y === position.y) {
                    activatePowerup(powerup.type);
                    scene.remove(powerup.mesh);
                    powerups.splice(i, 1);
                    break;
                }
            }
        }

        // Activate power-up
        function activatePowerup(type) {
            // Clear previous power-up
            activePowerup = type;
            powerupEndTime = Date.now() + 5000; // 5 seconds duration
            
            const notification = document.createElement('div');
            notification.className = 'powerup-notification';
            
            switch(type) {
                case 'speed':
                    speedMultiplier = 2;
                    notification.textContent = 'SPEED BOOST!';
                    notification.style.color = '#ffff00';
                    document.getElementById('speedIndicator').textContent = 'Speed: FAST!';
                    break;
                case 'slow':
                    speedMultiplier = 0.5;
                    notification.textContent = 'SLOW MOTION!';
                    notification.style.color = '#00ffff';
                    document.getElementById('speedIndicator').textContent = 'Speed: SLOW';
                    break;
                case 'invincible':
                    invincible = true;
                    notification.textContent = 'INVINCIBLE!';
                    notification.style.color = '#ff00ff';
                    // Make snake glow
                    snake.forEach(segment => {
                        segment.mesh.material.emissive = new THREE.Color(0x440044);
                    });
                    break;
            }
            
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 2000);
        }

        // Update power-ups
        function updatePowerups() {
            if (activePowerup && Date.now() > powerupEndTime) {
                // Reset power-up effects
                speedMultiplier = 1;
                invincible = false;
                document.getElementById('speedIndicator').textContent = 'Speed: Normal';
                
                // Reset snake appearance
                snake.forEach(segment => {
                    segment.mesh.material.emissive = new THREE.Color(0x000000);
                });
                
                activePowerup = null;
            }
            
            // Rotate power-up meshes
            powerups.forEach(powerup => {
                powerup.mesh.rotation.y += 0.05;
                powerup.mesh.rotation.x += 0.03;
                powerup.mesh.position.y = CELL_SIZE + Math.sin(Date.now() * 0.003) * 0.2;
            });
        }

        // Eat food
        function eatFood() {
            score += 10;
            document.getElementById('score').textContent = `Score: ${score}`;
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('snakeHighScore', highScore);
                document.getElementById('highScore').textContent = `High Score: ${highScore}`;
            }
            
            // Grow snake
            const tail = snake[snake.length - 1];
            const geometry = new THREE.BoxGeometry(CELL_SIZE * 0.9, CELL_SIZE * 0.9, CELL_SIZE * 0.9);
            const newSegment = new THREE.Mesh(geometry, snakeMaterial);
            newSegment.position.copy(tail.mesh.position);
            newSegment.castShadow = true;
            newSegment.receiveShadow = true;
            scene.add(newSegment);
            
            snake.push({
                position: { ...tail.position },
                mesh: newSegment
            });
            
            // Increase speed
            gameSpeed = Math.max(50, gameSpeed - SPEED_INCREMENT);
            
            // Create new food
            createFood();
            
            // Maybe create power-up
            createPowerup();
            
            // Create eat effect
            createEatEffect(food.mesh.position);
        }

        // Create eat effect
        function createEatEffect(position) {
            const particleCount = 20;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.1, 4, 4);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(Math.random(), 1, 0.5),
                    transparent: true
                });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    Math.random() * 0.3,
                    (Math.random() - 0.5) * 0.3
                );
                
                scene.add(particle);
                particles.push(particle);
            }
            
            // Animate particles
            let frame = 0;
            function animateParticles() {
                frame++;
                if (frame > 30) {
                    particles.forEach(p => scene.remove(p));
                    return;
                }
                
                particles.forEach(particle => {
                    particle.position.add(particle.velocity);
                    particle.material.opacity = 1 - frame / 30;
                    particle.scale.multiplyScalar(0.95);
                });
                
                requestAnimationFrame(animateParticles);
            }
            animateParticles();
        }

        // Game over
        function gameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOver').style.display = 'block';
        }

        // Restart game
        function restartGame() {
            gameRunning = true;
            score = 0;
            gameSpeed = INITIAL_SPEED;
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            speedMultiplier = 1;
            invincible = false;
            activePowerup = null;
            
            document.getElementById('score').textContent = `Score: 0`;
            document.getElementById('speedIndicator').textContent = 'Speed: Normal';
            document.getElementById('gameOver').style.display = 'none';
            
            // Clear power-ups
            powerups.forEach(powerup => scene.remove(powerup.mesh));
            powerups = [];
            
            initSnake();
            createFood();
        }

        // Handle keyboard input
        function handleKeyPress(event) {
            if (!gameRunning && event.key.toLowerCase() === 'r') {
                restartGame();
                return;
            }
            
            if (!gameRunning) return;
            
            switch(event.key.toLowerCase()) {
                case 'arrowup':
                case 'w':
                    if (direction.y === 0) {
                        nextDirection = { x: 0, y: -1 };
                    }
                    break;
                case 'arrowdown':
                case 's':
                    if (direction.y === 0) {
                        nextDirection = { x: 0, y: 1 };
                    }
                    break;
                case 'arrowleft':
                case 'a':
                    if (direction.x === 0) {
                        nextDirection = { x: -1, y: 0 };
                    }
                    break;
                case 'arrowright':
                case 'd':
                    if (direction.x === 0) {
                        nextDirection = { x: 1, y: 0 };
                    }
                    break;
            }
        }

        // Animation loop
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            // Update game
            if (gameRunning && currentTime - lastMoveTime > gameSpeed / speedMultiplier) {
                moveSnake();
                lastMoveTime = currentTime;
            }
            
            // Update power-ups
            updatePowerups();
            
            // Animate food
            if (food) {
                food.mesh.rotation.y += 0.02;
                food.mesh.position.y = Math.sin(currentTime * 0.003) * 0.2;
            }
            
            // Animate particles
            if (particleSystem) {
                particleSystem.rotation.y += 0.0005;
            }
            
            // Animate camera slightly
            const cameraOffset = Math.sin(currentTime * 0.0005) * 0.5;
            camera.position.x = cameraOffset;
            camera.lookAt(0, 0, 0);
            
            // Render
            renderer.render(scene, camera);
        }

        // Handle window resize
        function handleResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Update loading progress
        function updateLoadingProgress() {
            loadedAssets++;
            const percent = Math.round((loadedAssets / totalAssets) * 100);
            document.getElementById('loadingProgress').style.width = percent + '%';
            document.getElementById('loadingPercent').textContent = percent + '%';
        }

        // Initialize game
        async function init() {
            // Create asset manager
            assetManager = new AssetManager(ASSET_BASE_URL);
            
            try {
                // Load all assets
                await assetManager.loadAllAssets(updateLoadingProgress);
                
                // Hide loading screen
                document.getElementById('loadingScreen').style.display = 'none';
                
                // Initialize game
                initScene();
                initSnake();
                createFood();
                
                // Update high score display
                document.getElementById('highScore').textContent = `High Score: ${highScore}`;
                
                // Setup event listeners
                window.addEventListener('keydown', handleKeyPress);
                window.addEventListener('resize', handleResize);
                document.getElementById('restartBtn').addEventListener('click', restartGame);
                document.getElementById('skinSelect').addEventListener('change', () => {
                    if (gameRunning) {
                        const selectedSkin = document.getElementById('skinSelect').value;
                        snakeMaterial = assetManager.materials[`snake-${selectedSkin}`];
                        snake.forEach(segment => {
                            segment.mesh.material = snakeMaterial;
                        });
                    }
                });
                
                // Start animation
                animate(0);
                
            } catch (error) {
                console.error('Failed to initialize game:', error);
                document.getElementById('loadingText').textContent = 'Failed to load assets. Using fallback mode.';
                
                // Initialize with fallback materials after a delay
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                    initScene();
                    initSnake();
                    createFood();
                    document.getElementById('highScore').textContent = `High Score: ${highScore}`;
                    window.addEventListener('keydown', handleKeyPress);
                    window.addEventListener('resize', handleResize);
                    document.getElementById('restartBtn').addEventListener('click', restartGame);
                    animate(0);
                }, 2000);
            }
        }

        // Start the game
        init();
    </script>
</body>
</html>